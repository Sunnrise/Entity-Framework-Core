using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations.Schema;
using System.Reflection;
using System.Reflection.Emit;
using Sql_Queries.Configurations;

ApplicationDbContext context = new();


//If you can't express your query with LINQ or if you want to develop a more optimized query than the query generated by LINQ and execute it through EF Core, you should know that EF Core supports this behavior.

//In order to execute queries that are manually created by us through EF Core, an entity model that will receive the result of that query must be designed and this must be defined as DbSet in the context object.

#region FromSqlInterpolated
//FromSqlInterpolated method is used to execute queries that are manually created by us through EF Core. This method is used to execute queries that are created by us and that contain parameters.(Before EF Core 7.0)

//var people = await context.Persons.FromSqlInterpolated($"SELECT * FROM Persons").ToListAsync();
//FormattableString name = $"Alperen";
#endregion

#region Dynamic SQL Creation and Take Parameter - FromSqlRaw
string columnName = "PersonId";
SqlParameter value = new ("PersonId","3");
var people = await context.Persons.FromSqlRaw($"SELECT * FROM Persons Where {columnName}=@PersonId",value).ToListAsync();

//FromSql and FromSqlRaw methods are safe from SQL injection attacks. Because the parameters are passed to the query as parameters, not as a string.
//But If you want to use FromSqlRaw method, you should be careful about SQL injection attacks. Because the parameters are passed to the query as a string, not as a parameter. The developer responsible for the query should be careful about this.
#endregion
#region SqlQuery - Non Entity Scalar Queries- Non Entity - EF Core 7.0
// If you want to execute a query that does not return an entity, you can use the ExecuteSqlRaw method. This method is used to execute queries that do not return an entity.
var data=await context.Database.SqlQuery<int>($"SELECT PersonId Value FROM Persons").
    Where(x=> x>5).ToListAsync();
//If we use linQ after the query, we can use the Where method to filter the data. We use Value property to access the data in the query result.
#endregion
#region ExecuteSql
//Insert Update Delete
await context.Database.ExecuteSqlAsync($"Update Persons SET Name= 'Fatma' WHERE PersonId=1");
#endregion
#region Constraints

//Queries have to return all columns of the table. 
var persons = await context.Persons.FromSql($"SELECT Name, PersonId FROM Persons").ToListAsync();

//ColumnNames and PropertyNames must be the same.

//Sql Queries cant contain Join, GroupBy, OrderBy, etc. clauses. If you want to use these clauses, you should use Include method.
#endregion
Console.WriteLine();
public class Person
{
    public int PersonId { get; set; }
    public string Name { get; set; }

    public ICollection<Order> Orders { get; set; }
}
public class Order
{
    public int OrderId { get; set; }
    public int PersonId { get; set; }
    public string Description { get; set; }

    public Person Person { get; set; }
}

class ApplicationDbContext : DbContext
{
    public DbSet<Person> Persons { get; set; }
    public DbSet<Order> Orders { get; set; }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());

        modelBuilder.Entity<Person>()
            .HasMany(p => p.Orders)
            .WithOne(o => o.Person)
            .HasForeignKey(o => o.PersonId);
    }
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=localhost, 1433;Database=ApplicationDb;User Id=sa;Password=Password1;TrustServerCertificate=True");
    }
}



//CREATE PROC sp_GetAllPersons
//(
//	@PersonId INT NULL
//)AS
//BEGIN
//	IF @PersonId IS NULL
//		SELECT * FROM Persons
//	ELSE
//		SELECT * FROM Persons WHERE PersonId = @PersonId
//END


